#! /bin/zsh

typeset -Ag M4_PROMPTSTATE  # Holds prompt state, to decide whether to chg it
typeset -g  M4_SEGMENTS     # Segments configuration
typeset -A  M4_SCHEME       # Color scheme




# =========== STYLES SETUP =====================================================

M4_SEGMENTS=(
    user
    dir
    git
)

M4_SCHEME=(

    dir_fg  022         # Current directory fg
    dir_bg  193         # Current directory bg

    usr_fg  006         # Current user fg
    usr_bg  023         # Current user bg

    su_fg   210         # Superuser fg
    su_bg   052         # Superuser bg

    git_bg  058
    git_fg  229

    separator '\ue0b0'  # Powerline |>

)






# =========== M4_PROMPTSTATE ===================================================
#   
#   KEY         MEANING
#   ----------------------------------------------------------------------------
#   readonly    Current folder has now write access (0 <=> rw, 1 <=> ro)
#   git         Current folder has git information (0-1)
#   branch   Git branch
#

m4_load_promptstate() {
    # Loads the prompt into $1

    typeset -A retval
    typeset gitstatus

    [[ -w . ]] && retval[readonly]=0 || retval[readonly]=1

    $(git status -b --porcelain &> /dev/null) && retval[git]=1 || retval[git]=0

    if [[ $retval[git] -eq 0 ]]; then
        retval[branch]="none"
    else
        retval[branch]=$(git rev-parse --abbrev-ref HEAD)
    fi

    # Now copy onto $1
    set -A $1 ${(kv)retval}
}




# =========== SEGMENTS =========================================================

segment_user_color() {

    # Redefine color scheme to obtain custom colors
    case $1 in
        fg) # foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_fg]}%}.%{%F{$M4_SCHEME[usr_fg]}%})"
            ;;
        bg) # background
            echo -n "%(!.%{%K{$M4_SCHEME[su_bg]}%}.%{%K{$M4_SCHEME[usr_bg]}%})"
            ;;
        bginv) # background as foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_bg]}%}.%{%F{$M4_SCHEME[usr_bg]}%})"
            ;;
        fgbg)  # backgound and foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_fg]}%}%{%K{$M4_SCHEME[su_bg]}%}.%{%F{$M4_SCHEME[usr_fg]}%}%{%K{$M4_SCHEME[usr_bg]}%})"
            ;;
    esac

}

segment_user() {

    echo -n "%n"

    return 0
}



segment_git() {

    if [[ $M4_PROMPTSTATE[git] -eq 0 ]]; then
        return 1
    fi

    echo "\ue0a0 $M4_PROMPTSTATE[branch]"

    return 0
}



segment_dir() {

   echo -n "%30<â€¦<%~%<<"

    # Check if writable
    [[ $M4_PROMPTSTATE[readonly] -eq 1 ]] && echo -n " \ue0a2"   # locket

    return 0
}





# =========== SEGMENT DRAWING FUNC =============================================


m4_segment() {
    # Takes the id of the segment and outputs the body, by calling
    # `segment_${1}`.

    if whence segment_${1} > /dev/null; then

        segment_${1}

    fi
}

m4_segment_color() {
    # Takes the id of the segment as input and a code for which color to use
    # and applies it.
    # If a function `segment_${1}_color` is defined, that is called instead.
    #
    #   $1  id of the segment
    #   $2  one of the following:
    #       - `fg`: foreground
    #       - `bg`: background
    #       - `bginv`: background as foreground
    #       - `fgbg`: background and foreground
    #
    # The function will look up M4_SCHEME for entries in the form `${1}_fg` and
    # `${1}_bg` to extract the color.


    # Check if a custom function is available
    if whence segment_${1}_color > /dev/null; then

        # Custom function!
        segment_${1}_color $2

    else

        case $2 in
            fg) # foreground
                [[ -n $M4_SCHEME[${1}_fg] ]] && echo -n "%{%F{$M4_SCHEME[$1_fg]}%}"
                ;;
            bg) # background
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%K{$M4_SCHEME[$1_bg]}%}"
                ;;
            bginv) # background as foreground
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%F{$M4_SCHEME[$1_bg]}%}"
                ;;
            fgbg)  # backgound and foreground
                #segment_color $1 fg
                #segment_color $1 bg
                [[ -n $M4_SCHEME[${1}_fg] ]] && echo -n "%{%F{$M4_SCHEME[$1_fg]}%}"
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%K{$M4_SCHEME[$1_bg]}%}"
                ;;
        esac

    fi

}


m4_build_prompt() {

    local last body

    for current in $M4_SEGMENTS; do

        # Extract the value
        body=$(m4_segment $current)

        # Check if the return code is ok
        if [[ $? -eq 0 ]]; then

            # Ok this segment must be drawn.
            if [[ -n $last ]]; then

                # Draw the separator
                m4_segment_color $last bginv
                m4_segment_color $current bg
                echo -n $M4_SCHEME[separator]
                m4_segment_color $current fg

            else

                # Just set the colors
                m4_segment_color $current fgbg

            fi

            # Print the body
            echo -n " $body "

            # Save it
            last=$current

        fi

    done

    # Finish it!
    if [[ -n $last ]]; then

        m4_segment_color $last bginv
        echo -n "%{%k%}$M4_SCHEME[separator]%{%f%} "

    else

        # Echo an error prompt
        echo -n "NOSEG - %m%# "

    fi

}





# =========== HOOK =============================================================

m4_prompt_hook() {
    typeset -A newprompt
    local update=0

    # Update it
    m4_load_promptstate newprompt

    # Check if anything is different
    for key in "${(@k)newprompt}"; do
        
        if ! [[ -n $M4_PROMPTSTATE[$key] ]] ||
           [[ $M4_PROMPTSTATE[$key] -ne $newprompt[$key] ]] ||
           ! [[ $M4_PROMPTSTATE[$key] == $newprompt[$key] ]]; then
            # Set the flag & copy
            update=1
            M4_PROMPTSTATE[$key]=$newprompt[$key]
        fi

    done

    if [[ $update -eq 1 ]]; then
        PROMPT=$(m4_build_prompt)
    fi

}




# Use ZSH hooks for handling the prompt change
autoload -U add-zsh-hook

add-zsh-hook precmd m4_prompt_hook

