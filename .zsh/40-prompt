#! /bin/zsh
# Many ideas and git commands copied from
# https://github.com/digitalformula/zsh.prompts by digitalformula

typeset -Ag M4_PROMPTSTATE  # Holds prompt state, to decide whether to chg it
typeset -g  M4_SEGMENTS     # Segments configuration
typeset -g  M4_RSEGMENTS
typeset -A  M4_SCHEME       # Color scheme




# =========== STYLES SETUP =====================================================

M4_SEGMENTS=(
    user
    git
    dir
)

M4_RSEGMENTS=(
    machine
)

M4_SCHEME=(

    machine_fg      052
    machine_bg      234

    dir_fg          025
    dir_bg          015         
    
    usr_fg          153
    usr_bg          025
    
    su_fg           210
    su_bg           052

    git_dirty_fg    130
    git_dirty_bg    220
    
    git_clean_fg    022
    git_clean_bg    149

    separator       '\ue0b0'    # Powerline |>

)

# No term, or < 256 color
if ! $(echo $TERM | grep -q 256color); then

    M4_SCHEME[separator]='>'

fi




# =========== M4_PROMPTSTATE ===================================================
#   
#   KEY         MEANING
#   ----------------------------------------------------------------------------
#   readonly    Current folder has now write access (0 <=> rw, 1 <=> ro)
#   git         0 - no git info; 1 - inside git work tree; 2 - detached head
#   branch      Git branch
#   dirty       1 - work tree dirty; 0 - work tree clean
#

m4_load_promptstate() {
    # Loads the prompt into $1

    typeset -A retval
    typeset gitstatus

    # Check if current directory is readonly
    [[ -w . ]] && retval[readonly]=0 || retval[readonly]=1

    # Check if we're inside a git work tree
    if $(git rev-parse --is-inside-work-tree >/dev/null 2>&1); then

        # Get the branch name. This rev-parse is extremely useful.
        retval[git]=1

        # But it might be deatched!
        if $(git symbolic-ref HEAD &>/dev/null); then
            retval[git]=1
            retval[branch]=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        else
            retval[git]=2 # Detached!
            retval[branch]="$(git show-ref --head -s --abbrev |head -n1 2> /dev/null)"
        fi

        # Make sure the branch contains something or the copy onto $1 will fail
        if ! [[ -n $retval[branch] ]]; then
            retval[branch]="none"
        fi

        # Parse clean/dirty flag
        $(git-clean) && retval[dirty]=0 || retval[dirty]=1

    else

        retval[git]=0
        retval[branch]="none"
        retval[dirty]=0

    fi

    # Now copy onto $1
    set -A $1 ${(kv)retval}
}




# =========== SEGMENTS =========================================================

segment_git_color() {
    # Check if clean or dirty
    if [[ $M4_PROMPTSTATE[dirty] -eq 1 ]]; then
        m4_segment_color git_dirty $1
    else
        m4_segment_color git_clean $1
    fi
}

segment_user_color() {
    # We want super user to use a different color scheme

    # Redefine color scheme to obtain custom colors
    case $1 in
        fg) # foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_fg]}%}.%{%F{$M4_SCHEME[usr_fg]}%})"
            ;;
        bg) # background
            echo -n "%(!.%{%K{$M4_SCHEME[su_bg]}%}.%{%K{$M4_SCHEME[usr_bg]}%})"
            ;;
        bginv) # background as foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_bg]}%}.%{%F{$M4_SCHEME[usr_bg]}%})"
            ;;
        fgbg)  # backgound and foreground
            echo -n "%(!.%{%F{$M4_SCHEME[su_fg]}%}%{%K{$M4_SCHEME[su_bg]}%}.%{%F{$M4_SCHEME[usr_fg]}%}%{%K{$M4_SCHEME[usr_bg]}%})"
            ;;
    esac

}

segment_machine() {

    # Print the machine name
    echo -n "%m"

    return 0

}

segment_user() {
    # Print just %n aka username

    echo -n "%n"

    return 0
}



segment_git() {
    # Return failure if we aren't inside a git work tree

    if [[ $M4_PROMPTSTATE[git] -eq 0 ]]; then

        return 1

    elif [[ $M4_PROMPTSTATE[git] -eq 1 ]]; then

        # Print branch symbol and branch name
        echo "\ue0a0 $M4_PROMPTSTATE[branch]"

    elif [[ $M4_PROMPTSTATE[git] -eq 2 ]]; then

        # Print detached head symbol and ref code
        echo "\u27a6 $M4_PROMPTSTATE[branch]"

    fi
    
    return 0
}



segment_dir() {

    # Check if writable and print a padlock
    [[ $M4_PROMPTSTATE[readonly] -eq 1 ]] && echo -n "\ue0a2 "   # locket

    # Trim the directory
    echo -n "%30<â€¦<%~%<<"

    return 0
}





# =========== SEGMENT DRAWING FUNC =============================================


m4_segment() {
    # Takes the id of the segment and outputs the body, by calling
    # `segment_${1}`.

    if whence segment_${1} > /dev/null; then

        segment_${1}

    fi
}

m4_segment_color() {
    # Takes the id of the segment as input and a code for which color to use
    # and applies it.
    # If a function `segment_${1}_color` is defined, that is called instead.
    #
    #   $1  id of the segment
    #   $2  one of the following:
    #       - `fg`: foreground
    #       - `bg`: background
    #       - `bginv`: background as foreground
    #       - `fgbg`: background and foreground
    #
    # The function will look up M4_SCHEME for entries in the form `${1}_fg` and
    # `${1}_bg` to extract the color.


    # Check if a custom function is available
    if whence segment_${1}_color > /dev/null; then

        # Custom function!
        segment_${1}_color $2

    else

        case $2 in
            fg) # foreground
                [[ -n $M4_SCHEME[${1}_fg] ]] && echo -n "%{%F{$M4_SCHEME[${1}_fg]}%}"
                ;;
            bg) # background
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%K{$M4_SCHEME[${1}_bg]}%}"
                ;;
            bginv) # background as foreground
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%F{$M4_SCHEME[${1}_bg]}%}"
                ;;
            fgbg)  # backgound and foreground
                #segment_color $1 fg
                #segment_color $1 bg
                [[ -n $M4_SCHEME[${1}_fg] ]] && echo -n "%{%F{$M4_SCHEME[${1}_fg]}%}"
                [[ -n $M4_SCHEME[${1}_bg] ]] && echo -n "%{%K{$M4_SCHEME[${1}_bg]}%}"
                ;;
        esac

    fi

}


m4_build_prompt() {
    # Prints the final prompt.
    # Enumerate `M4_SEGMENTS`. For each segment, evaluate the body. If the
    # return code is 0, then display it by drawing the separator. Otherwise,
    # go to the next.

    local last body

    for current in $M4_SEGMENTS; do

        # Extract the value
        body=$(m4_segment $current)

        # Check if the return code is ok
        if [[ $? -eq 0 ]]; then

            # Ok this segment must be drawn.
            if [[ -n $last ]]; then

                # Draw the separator
                m4_segment_color $last bginv
                m4_segment_color $current bg
                echo -n $M4_SCHEME[separator]
                m4_segment_color $current fg

            else

                # Just set the colors
                m4_segment_color $current fgbg

            fi

            # Print the body
            echo -n " $body "

            # Save it
            last=$current

        fi

    done

    # Finish it!
    if [[ -n $last ]]; then

        m4_segment_color $last bginv
        echo -n "%{%k%}$M4_SCHEME[separator]%{%f%} "

    else

        # Echo an error prompt
        echo -n "NOSEG - %m%# "

    fi

}

m4_build_rprompt() {
    # Prints the final rprompt.
    # Enumerate `M4_RSEGMENTS`. For each segment, evaluate the body. If the
    # return code is 0, then display it by drawing the separator. Otherwise,
    # go to the next.

    local last body

    for current in $M4_RSEGMENTS; do

        # Extract the value
        body=$(m4_segment $current)

        # Check if the return code is ok
        if [[ $? -eq 0 ]]; then

            # Ok this segment must be drawn.
            if [[ -n $last ]]; then

                # Draw the separator
                m4_segment_color $last bginv
                m4_segment_color $current bg
                echo -n $M4_SCHEME[separator]
                m4_segment_color $current fg

            else

                # Use standout mode
                echo -n "%S"
                m4_segment_color $current bginv
                echo -n $M4_SCHEME[separator]
                echo -n "%s"
                m4_segment_color $current fgbg

            fi

            # Print the body
            echo -n " $body "

            # Save it
            last=$current

        fi

    done

    # Finish it!
    if [[ -n $last ]]; then

        echo -n "%{%k%}%{%f%}"

    fi

}





# =========== HOOK =============================================================

m4_prompt_hook() {
    # PRECMD hook. Compute the new prompt state, and if it differs, then
    # rebuild the prompt.
    typeset -A newprompt
    local update=0

    # Update it
    m4_load_promptstate newprompt

    # Check if anything is different
    for key in "${(@k)newprompt}"; do
        
        if ! [[ -n $M4_PROMPTSTATE[$key] ]] ||
           ! [[ $M4_PROMPTSTATE[$key] == $newprompt[$key] ]]; then
            # Set the flag & copy
            update=1
            M4_PROMPTSTATE[$key]=$newprompt[$key]
        fi

    done

    if [[ $update -eq 1 ]]; then
        PROMPT=$(m4_build_prompt)
        RPROMPT=$(m4_build_rprompt)
    fi

}




# Use ZSH hooks for handling the prompt change
autoload -U add-zsh-hook

add-zsh-hook precmd m4_prompt_hook

